/* @Author Ted Adams (tadams2@umbc.edu
 *  This file contains the code for a character device called Scrubber
 *  this character device handles writes to the device by adding the words to
 *  a kernel linked list
 *
 *  This device also catches and handles interrupts, the interrupts are generated by network packets sent over the internet
 *  This device will then censor those packets
 */

/*
 * This file uses kernel-doc style comments, which is similar to
 * Javadoc and Doxygen-style comments.  See
 * ~/linux/Documentation/kernel-doc-nano-HOWTO.txt for details.
 */

/*
 * Getting compilation warnings?  The Linux kernel is written against
 * C89, which means:
 *  - No // comments, and
 *  - All variables must be declared at the top of functions.
 * Read ~/linux/Documentation/CodingStyle to ensure your project
 * compiles without warnings.
 */

#include <linux/fs.h>
#include <linux/gfp.h>
#include <linux/init.h>
#include <linux/interrupt.h>
#include <linux/miscdevice.h>
#include <linux/module.h>
#include <linux/slab.h>
#include <asm/uaccess.h>

#include <linux/list.h>
#include <linux/spinlock.h>
#include <linux/string.h>
#define PREFIX "SCRUBBER: "

/*
 * Read xt_filter.c to learn how to use these two functions.
 */
#define FILTER_IRQ 6
extern void filter_enable(void);
extern void filter_disable(void);
extern void filter_resume(void);
extern char *filter_get_payload(size_t *);
static DEFINE_SPINLOCK(lock);
static DEFINE_SPINLOCK(bottom_lock);
LIST_HEAD(myDirtyList);
unsigned long flags;

struct DirtyWordNode {
	char *dirtyWord;
	struct list_head list;
};

struct DirtyWordNode dirtyList;

/**
 * scrubber_open() - callback invoked when a process tries to open
 * /dev/scrubber
 * @inode: inode of character device (ignored)
 * @filp: process's file object (ignored)
 *
 * Return: always 0
 */
static int scrubber_open(struct inode *inode, struct file *filp)
{
	return 0;
}

/* SOURCES: www.roman10.net/linux-kernel-programminglinked-list/ , 
            apiexamples.com/c/string/strsep.html                
*/
/**
 * scrubber_write() - callback invoked when a process writes to
 * /dev/scrubber
 * @filp: process's file object (ignored)
 * @ubuf: source buffer
 * @count: number of bytes in @ubuf
 * @ppos: file offset (ignored)
 *
 * Copy from @ubuf into a local buffer, the lesser of @count or 80
 * bytes. Tokenize the buffer, splitting on the newline ('\n')
 * character. For each token, add it to an internal list of "dirty
 * words".
 *
 * WARNING: @ubuf is not null-terminated.
 *
 * HINT: strsep() and kstrdup() are useful here.
 *
 * Return: @count on success, negative on error
 */
static ssize_t scrubber_write(struct file *filp, const char __user * ubuf,
			      size_t count, loff_t * ppos)
{
	int retval;
	char buf[81];
	/* my kernel would lock when testing with \n when sending stuff across telnet so i used | instead */
	char *delim = "|";
	char *token;
	char *str;
	/*defining the new node and aNode as an iterator */
	struct DirtyWordNode *newDirtyNode;
	struct DirtyWordNode *aNode = NULL;

	spin_lock_irqsave(&lock, flags);
	count = min(count, sizeof(buf) - 1);

	retval = copy_from_user(buf, ubuf, count);
	if (retval < 0) {
		spin_unlock_irqrestore(&lock, flags);
		return retval;
	}

	/* NULL terminating the buffer */

	str = kstrdup(ubuf, GFP_KERNEL);
	str[count] = '\0';
	if (str == NULL) {
		return -1;
	}
	/* seperating the buffer on \n ending on NULL terminator */

	while (str != NULL) {
		/* seperate the string by the delim and put it in token */
		token = strsep(&str, delim);
		if (token != NULL) {
			newDirtyNode =
			    kmalloc(sizeof(*newDirtyNode), GFP_KERNEL);
			/* put the token into the new dirty nodes data section */
			newDirtyNode->dirtyWord = token;

			/* init the list head for the new dirty node */
			INIT_LIST_HEAD(&newDirtyNode->list);
			/* add the newly created node into the list */
			list_add_tail(&(newDirtyNode->list), &(dirtyList.list));
		}
	}
	/* debugging list traversal */
	list_for_each_entry(aNode, &dirtyList.list, list) {
		printk(KERN_INFO "at word %s ", aNode->dirtyWord);
	}

	spin_unlock_irqrestore(&lock, flags);
	return count;
}

/**
 * scrubber_check() - top-half of scrubber ISR
 * @irq: IRQ that was invoked
 * @cookie: Pointer to data that was passed into
 * register_threader_irq() (ignored)
 *
 * If @irq is FILTER_IRQ, then wake up the bottom-half. Otherwise,
 * return IRQ_NONE.
 */

static irqreturn_t scrubber_check(int irq, void *cookie)
{
	irqreturn_t retval;
	if (irq == FILTER_IRQ) {
		spin_lock_irqsave(&lock, flags);
		retval = IRQ_WAKE_THREAD;
		spin_unlock_irqrestore(&lock, flags);
		return retval;
	} else {
		return IRQ_NONE;
	}
}

/**
 * scrubber_handler() - bottom-half to scrubber ISR
 * @irq: IRQ that was invoked
 * @cookie: Pointer that was passed into register_threaded_irq()
 * (ignored)
 *
 * For each word in the dirty word list, scan the payload for that
 * word. For each instance found, case-sensitive matching, overwrite
 * that part of the payload with asterisks. Afterwords, resume the
 * Internet filter.
 *
 * HINT: use list_for_each_entry() to iterate over the dirty word list
 * HINT: strnstr()/memcmp() and memset() are useful here.
 *
 * WARNING: The payload is not null-terminated.
 *
 * Return: always IRQ_HANDLED
 */

static irqreturn_t scrubber_handler(int irq, void *cookie)
{
	char *ptr;
	size_t payloadLen = 0;
	struct DirtyWordNode *aNode = NULL;
	size_t wordLen;
	char *payload_data = filter_get_payload(&payloadLen);
	/* gets the payload data and NULL terminates it */
	payload_data[payloadLen] = '\0';
	printk("payload: %s\n", payload_data);
	printk("payload length: %zu\n", payloadLen);
	spin_lock_irqsave(&bottom_lock, flags);

	/* traverse the list */
	list_for_each_entry(aNode, &dirtyList.list, list) {
		/* gets the length of the word we are at so we know how many characters to turn into asterisks */
		wordLen = strlen(aNode->dirtyWord);
		/* while the pointer to the matching substring is not NULL (strnstr() returns NULL if no match is found in the substring */
		while ((ptr =
			strnstr(payload_data, aNode->dirtyWord,
				sizeof(aNode->dirtyWord))) != NULL) {
			/* making sure we are accessing a word with a length */
			if (wordLen > 0) {
				/* sets the matching pointer to wordLen number of asterisks */
				memset(ptr, '*', wordLen);
			}
		}
	}

	/*unlock and resume filter and let top half know we are done handling the interrupt */

	spin_unlock_irqrestore(&bottom_lock, flags);
	filter_resume();
	return IRQ_HANDLED;
}

static const struct file_operations scrubber_fops = {
	.owner = THIS_MODULE,
	.open = scrubber_open,
	.write = scrubber_write
};

static struct miscdevice scrubber_dev = {
	.minor = MISC_DYNAMIC_MINOR,
	.name = "scrubber",
	.fops = &scrubber_fops,
	.mode = 0222,
};

/**
 * scrubber_init() - entry point into the scubber kernel module
 * Return: 0 on successful initialization, negative on error
 */
static int __init scrubber_init(void)
{
	int retval;
	spin_lock_irqsave(&lock, flags);
	INIT_LIST_HEAD(&dirtyList.list);
	retval = misc_register(&scrubber_dev);
	if (retval) {
		pr_err(PREFIX "Could not register device\n");
		spin_unlock_irqrestore(&lock, flags);
		return -ENODEV;
	}
	if (request_threaded_irq
	    (FILTER_IRQ, scrubber_handler, scrubber_check, 0, "Scrubber",
	     NULL) < 0) {
		return -1;
	}

	filter_enable();
	spin_unlock_irqrestore(&lock, flags);
	return 0;
}

/**
 * scrubber_exit() - called by kernel to clean up resources
 */
static void __exit scrubber_exit(void)
{
	struct DirtyWordNode *tmp, *node;

	filter_disable();
	spin_lock_irqsave(&lock, flags);

	/* destroying the list and freeing the memory */
	list_for_each_entry_safe(node, tmp, &dirtyList.list, list) {
		printk(KERN_INFO " freeing node %s\n", node->dirtyWord);

		list_del(&node->list);
		kfree(node);

	}
	spin_unlock_irqrestore(&lock, flags);
	free_irq(FILTER_IRQ, NULL);
	misc_deregister(&scrubber_dev);
}

module_init(scrubber_init);
module_exit(scrubber_exit);

MODULE_DESCRIPTION("CS421 scrubber driver");
MODULE_LICENSE("GPL");
